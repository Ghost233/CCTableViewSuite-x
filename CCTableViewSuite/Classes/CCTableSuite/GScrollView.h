////  GScrollView.h//  GTable////  http://www.opensource.org/licenses/mit-license.php////  Created by Sangwoo Im on 6/3/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#ifndef __GScrollView_H__#define __GScrollView_H__#include "CCLayer.h"#include "cocos2d.h"#include "GTableViewSuiteConfig.h"using namespace cocos2d;#include "GScrollViewDelegate.h"/** * ScrollView support for cocos2d for iphone. * It provides scroll view functionalities to cocos2d projects natively. * * !!!Important!!! * If clipToBounds is true, you must not add scroll views as descendants at any depth. */class GScrollView : public CCLayer{    /**     * scroll view delegate     */    CC_SYNTHESIZE(GScrollViewDelegate* , delegate, Delegate);    /**     * If true, the view is being dragged.     */    CC_SYNTHESIZE_READONLY(bool, isDragging, IsDragging)    /**     * Determines whether the scroll view is allowed to bounce or not.     */    CC_SYNTHESIZE(bool, bounces, Bounces);    /**     * direction allowed to scroll. GScrollViewDirectionBoth by default.     */    CC_SYNTHESIZE(GScrollViewDirection, direction, Direction);    /**     * If true, it clips its children to the visible bounds (view size)     * it is true by default.     */    CC_SYNTHESIZE(bool, clipToBounds, ClipToBounds);    /**     * Content offset. Note that left-bottom point is the origin     */    CC_PROPERTY(CCPoint, contentOffset, ContentOffset);    /**     * ScrollView size which is different from contentSize. This size determines visible     * bounding box.     */    G_PROPERTY_DEFINE(CCSize, viewSize, ViewSize);    /**     * container is a protected property     */    CC_SYNTHESIZE_RETAIN(CCLayer*, container, Container);    /**     * initial touch point     */    CC_SYNTHESIZE(CCPoint, touchPoint, TouchPoint);    /**     * determines whether touch is moved after begin phase     */    CC_SYNTHESIZE(bool, touchMoved, TouchMoved);    /**     * Returns an autoreleased scroll view object.     *     * @param size view size     * @return autoreleased scroll view object     */    static GScrollView* scrollViewWithViewSize(CCSize size);    /**     * Returns a scroll view object     *     * @param size view size     * @return scroll view object     */    virtual bool initWithViewSize(CCSize size);    /**     * Sets a new content offset. It ignores max/min offset. It just sets what's given. (just like UIKit's UIScrollView)     *     * @param offset new offset     * @param If true, the view scrolls to the new offset     */    virtual void setContentOffset(CCPoint offset, bool animated);    /**     * Returns the current container's minimum offset. You may want this while you animate scrolling by yourthis     */    virtual CCPoint minContainerOffset();    /**     * Returns the current container's maximum offset. You may want this while you animate scrolling by yourthis     */    virtual CCPoint maxContainerOffset();            virtual CCSize getContentSize();    virtual void setContentSize(CCSize size);    virtual void addChild(CCNode *node);    virtual void addChild(CCNode *node, int z);    virtual void addChild(CCNode *node, int z, int aTag);        virtual void beforeDraw();    virtual void afterDraw();    virtual void visit();    virtual void ccTouchesBegan(CCSet *touches, CCEvent *event);    virtual void ccTouchesMoved(CCSet *touches, CCEvent *event);    virtual void ccTouchesEnded(CCSet *touches, CCEvent *event);    virtual void ccTouchesCancelled(CCSet *touches, CCEvent *event);    /**     * max inset point to limit scrolling by touch     */    CCPoint maxInset;    /**     * min inset point to limit scrolling by touch     */    CCPoint minInset;    /**     * scroll speed     */    CCPoint scrollDistance;        /**     * Relocates the container at the proper offset, in bounds of max/min offsets.     *     * @param animated If true, relocation is animated     */    virtual void relocateContainer(bool animated);    /**     * implements auto-scrolling behavior. change SCROLL_DEACCEL_RATE as needed to choose     * deacceleration speed. it must be less than 1.0f.     *     * @param dt delta     */    virtual void deaccelerateScrolling(CCTime dt);    /**     * This method makes sure auto scrolling causes delegate to invoke its method     */    virtual void performedAnimatedScroll(CCTime dt);    /**     * Expire animated scroll delegate calls     */    virtual void stoppedAnimatedScroll(CCNode *node);};#endif // __GScrollView_H__