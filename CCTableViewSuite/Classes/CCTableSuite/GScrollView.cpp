////  GScrollView.m//  GTable////  Created by Sangwoo Im on 6/3/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#include "GScrollView.h"#include "CCGeometry.h"#include "CCPointExtension.h"#include "GScrollViewDelegate.h"#define SCROLL_DEACCEL_RATE  0.95f#define SCROLL_DEACCEL_DIST  1.0f#define BOUNCE_DURATION      0.35f#define BOUNCE_STEP          0.1#define INSET_RATIO          0.3fG_SYNTHESIZE_IMPLEMENT_GET(CCSize, viewSize, ViewSize, GScrollView);GScrollView* GScrollView::scrollViewWithViewSize(CCSize size){    GScrollView *temp = new GScrollView();    temp->initWithViewSize(size);    temp->autorelease();    return temp;}bool GScrollView::initWithViewSize(CCSize size){    this->init();    this->setContainer(CCLayer::create());    this->setViewSize(size);            this->setDelegate(NULL);    this->setBounces(true);    this->setClipToBounds(true);    this->getContainer()->setContentSize(CCSizeZero);    this->setDirection(GScrollViewDirectionBoth);    this->getContainer()->setPosition(ccp(0.0f, 0.0f));            this->CCLayer::addChild(container);    CCDirector::sharedDirector()->getTouchDispatcher()->addStandardDelegate(this, 0);    return this;}void GScrollView::setContentOffset(CCPoint offset){    this->setContentOffset(offset, false);}void GScrollView::setContentOffset(CCPoint offset, bool animated){    if (animated)//animate scrolling    {        CCFiniteTimeAction *scroll, *expire;                scroll = CCMoveTo::create(BOUNCE_DURATION, offset);        expire = CCCallFunc::create(this, callfunc_selector(GScrollView::stoppedAnimatedScroll));        this->getContainer()->runAction(CCSequence::create(scroll, expire, NULL));        this->schedule(schedule_selector(GScrollView::performedAnimatedScroll));            }    else //set the container position directly    {        this->getContainer()->setPosition(offset);        this->getDelegate()->scrollViewDidScroll(this);    }}CCPoint GScrollView::getContentOffset(){    return this->getContainer()->getPosition();}void GScrollView::setViewSize(CCSize size){    if (!CCSize::CCSizeEqualToSize(viewSize, size))    {        viewSize = size;        maxInset = this->maxContainerOffset();        maxInset = ccp(maxInset.x + this->getViewSize().width * INSET_RATIO,                        maxInset.y + this->getViewSize().height * INSET_RATIO);        minInset = this->minContainerOffset();        minInset = ccp(minInset.x - this->getViewSize().width * INSET_RATIO,                        minInset.y - this->getViewSize().height * INSET_RATIO);    }}void GScrollView::relocateContainer(bool animated){    CCPoint oldPoint, min, max;    CCFloat newX, newY;        min = this->minContainerOffset();    max = this->maxContainerOffset();        oldPoint = container->getPosition();    newX     = MIN(oldPoint.x, max.x);    newX     = MAX(newX, min.x);    newY     = MIN(oldPoint.y, max.y);    newY     = MAX(newY, min.y);    if (newY != oldPoint.y || newX != oldPoint.x)    {        this->setContentOffset(ccp(newX, newY), animated);    }}                               CCPoint GScrollView::maxContainerOffset(){    return ccp(0.0f, 0.0f);}                               CCPoint GScrollView::minContainerOffset(){    float x = this->getViewSize().width - this->getContentSize().width;    float y = this->getViewSize().height - this->getContentSize().height;    return ccp(x, y);}        void GScrollView::deaccelerateScrolling(CCTime dt){    if (isDragging) {        this->unschedule(schedule_selector(GScrollView::deaccelerateScrolling));        return;    }        CCFloat newX, newY;    CCPoint maxInset, minInset;    this->getContainer()->setPosition(ccpAdd(this->getContainer()->getPosition(), scrollDistance));        if (bounces) {        maxInset = this->maxInset;        minInset = this->minInset;    } else {        maxInset = this->maxContainerOffset();        minInset = this->minContainerOffset();    }        //check to see if offset lies within the inset bounds    newX     = MIN(container->getPosition().x, maxInset.x);    newX     = MAX(newX, minInset.x);    newY     = MIN(container->getPosition().y, maxInset.y);    newY     = MAX(newY, minInset.y);        scrollDistance     = ccpSub(scrollDistance, ccp(newX - container->getPosition().x, newY - container->getPosition().y));    scrollDistance     = ccpMult(scrollDistance, SCROLL_DEACCEL_RATE);    this->setContentOffset(ccp(newX, newY));        if ((fabsf(scrollDistance.x) <= SCROLL_DEACCEL_DIST &&         fabsf(scrollDistance.y) <= SCROLL_DEACCEL_DIST) ||        newX == maxInset.x || newX == minInset.x ||        newY == maxInset.y || newY == minInset.y)    {        this->unschedule(schedule_selector(GScrollView::deaccelerateScrolling));        this->relocateContainer(true);    }}                               void GScrollView::stoppedAnimatedScroll(CCNode *node){    this->unschedule(schedule_selector(GScrollView::performedAnimatedScroll));}                               void GScrollView::performedAnimatedScroll(CCTime dt){    if (isDragging)    {        this->unschedule(schedule_selector(GScrollView::performedAnimatedScroll));        return;    }    delegate->scrollViewDidScroll(this);}                               CCSize GScrollView::getContentSize(){    float a1 = this->getScaleX();    a1 *= this->getContainer()->getContentSize().width;    float a2 = this->getScaleY();    a2 *= this->getContainer()->getContentSize().height;    return CCSizeMake(a1, a2);}                               void GScrollView::setContentSize(CCSize size){    if (container == NULL) return;    this->getContainer()->setContentSize(size);    maxInset = this->maxContainerOffset();    maxInset = ccp(maxInset.x + this->getViewSize().width * INSET_RATIO,                    maxInset.y + this->getViewSize().height * INSET_RATIO);    minInset = this->minContainerOffset();    minInset = ccp(minInset.x - this->getViewSize().width * INSET_RATIO,                    minInset.y - this->getViewSize().height * INSET_RATIO);}void GScrollView::addChild(CCNode *node){    this->addChild(node, node->getZOrder(), node->getTag());}void GScrollView::addChild(CCNode *node, int z){    this->addChild(node, z, node->getTag());}/** * make sure all children go to the container */void GScrollView::addChild(CCNode *node, int z, int aTag){    node->ignoreAnchorPointForPosition(true);    node->setAnchorPoint(ccp(0.0f, 0.0f));    if (container != node)    {        this->getContainer()->addChild(node, z, aTag);    }    else    {        this->CCLayer::addChild(node, z, aTag);    }}                               void GScrollView::beforeDraw(){    if (clipToBounds)    {        // TODO: This scrollview should respect parents' positions        CCPoint screenPos = this->convertToWorldSpace(this->getParent()->getPosition());                            glEnable(GL_SCISSOR_TEST);        float s = this->getScale();                        CCDirector *director = CCDirector::sharedDirector();        s *= director->getContentScaleFactor();                        glScissor((GLint)this->getPosition().x, (GLint)this->getPosition().y, (GLsizei)(this->getViewSize().width*s), (GLsizei)(this->getViewSize().height*s));                    }}     void GScrollView::afterDraw(){    if (clipToBounds)    {        glDisable(GL_SCISSOR_TEST);    }}                               //void GScrollView::beforeDraw()//{//    if (clipToBounds)//    {////        GLfloat planeTop[]    = {0.0f, -1.0f, 0.0f, viewSize.height};////        GLfloat planeBottom[] = {0.0f, 1.0f, 0.0f, 0.0f};////        GLfloat planeLeft[]   = {1.0f, 0.0f, 0.0f, 0.0f};////        GLfloat planeRight[]  = {-1.0f, 0.0f, 0.0f, viewSize.width};//        //        GLfloat planeTop[]    = {0.0f, -1.0f, 0.0f, this->getPosition().y + viewSize.height};//        GLfloat planeBottom[] = {0.0f, 1.0f, 0.0f, -this->getPosition().y};//        GLfloat planeLeft[]   = {1.0f, 0.0f, 0.0f, -this->getPosition().x};//        GLfloat planeRight[]  = {-1.0f, 0.0f, 0.0f, this->getPosition().x + viewSize.width};//        //        glClipPlanef(GL_CLIP_PLANE0, planeTop);//        glClipPlanef(GL_CLIP_PLANE1, planeBottom);//        glClipPlanef(GL_CLIP_PLANE2, planeLeft);//        glClipPlanef(GL_CLIP_PLANE3, planeRight);//        glEnable(GL_CLIP_PLANE0);//        glEnable(GL_CLIP_PLANE1);//        glEnable(GL_CLIP_PLANE2);//        glEnable(GL_CLIP_PLANE3);//    }//}//                               //void GScrollView::afterDraw()//{//    if (clipToBounds)//    {//        glDisable(GL_CLIP_PLANE0);//        glDisable(GL_CLIP_PLANE1);//        glDisable(GL_CLIP_PLANE2);//        glDisable(GL_CLIP_PLANE3);//    }//}                               void GScrollView::visit(){    this->beforeDraw();    CCLayer::visit();    this->afterDraw();}void GScrollView::ccTouchesBegan(CCSet *touches, CCEvent *event){    if (!this->isVisible())    {        return;    }    CCRect frame;        frame = CCRectMake(this->getPosition().x, this->getPosition().y, this->getViewSize().width, this->getViewSize().height);    //dispatch does not know about clipping. reject touches outside visible bounds.    CCSetIterator iter = touches->begin();    for (; iter != touches->end(); iter++)    {        CCTouch* pTouch = (CCTouch*)(*iter);        CCPoint touch = this->convertTouchToNodeSpace(pTouch);        touch = this->convertToWorldSpace(touch);        if (!CCRect::CCRectContainsPoint(frame, touch))        {            touchPoint = ccp(-1.0f, -1.0f);            isDragging = false;            return;        }    }        if (touches->count() == 1)// scrolling    {        touchPoint = this->convertTouchToNodeSpace((CCTouch *) touches->anyObject());    }    else// 2 or more touches would mean something else?    {        //invalidate initial values        touchPoint = ccp(-1.0f, -1.0f);    }     touchMoved     = false;    isDragging     = true; //dragging started    scrollDistance = ccp(0.0f,0.0f);}            void GScrollView::ccTouchesMoved(CCSet *touches,CCEvent *event){    if (!this->isVisible())    {        return;    }    touchMoved = true;    if (touches->count() == 1 && !CCPoint::CCPointEqualToPoint(ccp(-1.0f,-1.0f), touchPoint) && isDragging)// scrolling    {        CCPoint moveDistance, newPoint, maxInset, minInset;        CCRect  frame;        CCFloat newX, newY;                frame        = CCRectMake(this->getPosition().x, this->getPosition().y, this->getViewSize().width, this->getViewSize().height);        newPoint     = this->convertTouchToNodeSpace((CCTouch *) touches->anyObject());        moveDistance = ccpSub(newPoint, touchPoint);        touchPoint  = newPoint;                if (CCRect::CCRectContainsPoint(frame, this->convertToWorldSpace(newPoint)))        {            switch (direction) {                case GScrollViewDirectionVertical:                    moveDistance = ccp(0.0f, moveDistance.y);                    break;                case GScrollViewDirectionHorizontal:                    moveDistance = ccp(moveDistance.x, 0.0f);                    break;                default:                    break;            }            this->getContainer()->setPosition(ccpAdd(container->getPosition(), moveDistance));                        if (bounces)            {                maxInset = this->maxInset;                minInset = this->minInset;            }            else            {                maxInset = this->maxContainerOffset();                minInset = this->minContainerOffset();            }                        //check to see if offset lies within the inset bounds            newX     = MIN(container->getPosition().x, maxInset.x);            newX     = MAX(newX, minInset.x);            newY     = MIN(container->getPosition().y, maxInset.y);            newY     = MAX(newY, minInset.y);                        scrollDistance     = ccpSub(moveDistance, ccp(newX - container->getPosition().x, newY - container->getPosition().y));            this->setContentOffset(ccp(newX, newY));        }    }}            void GScrollView::ccTouchesEnded(CCSet *touches, CCEvent *event){    if (!this->isVisible())    {        return;    }    isDragging = false;    if (touches->count() == 1 && !CCPoint::CCPointEqualToPoint(ccp(-1.0f,-1.0f), touchPoint) && touchMoved)    {        this->schedule(schedule_selector(GScrollView::deaccelerateScrolling));    }}                    void GScrollView::ccTouchesCancelled(CCSet *touches, CCEvent *event){    if (!this->isVisible())    {        return;    }    this->ccTouchesEnded(touches, event);}