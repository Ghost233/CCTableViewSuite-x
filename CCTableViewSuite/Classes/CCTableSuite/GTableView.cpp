////  GTableView.m//  GTable////  Created by Sangwoo Im on 6/3/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#include "GTableView.h"#include "GTableViewCell.h"#include "CCMenu.h"#include "CCPointExtension.h"#include "CCLayer.h"GTableView::~GTableView(){    CC_SAFE_RELEASE(cellsFreed);    CC_SAFE_RELEASE(cellsUsed);}GTableView* GTableView::tableViewWithDataSource(GTableViewDataSource* dataSource, CCSize size){    GTableView *table = new GTableView();    table->initWithViewSize(size);    table->setDataSource(dataSource);    table->updateContentSize();    table->autorelease();    return table;}bool GTableView::initWithViewSize(CCSize size){    this->GScrollView::initWithViewSize(size);    this->setCellsFreed(CCArray::create());    this->setCellsUsed(CCArray::create());    this->setIsEnabled(true);    this->setTDelegate(NULL);    this->setDirection(GScrollViewDirectionVertical);    this->GScrollView::setDelegate(this);    return true;}void GTableView::setDelegate(GScrollViewDelegate* delegate){    if (delegate)	{        //CCLOG(@"%s: %s: you cannot set this delegate. use tDelegate instead.", __FILE__, __FUNCTION__);    }}void GTableView::reloadData(){    CCObject *cellTemp;    CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        cellsFreed->addObject(cell);        cell->setIdx(LONG_MAX);        cell->getMnode()->setVisible(false);    }    CC_SAFE_RELEASE(cellsUsed);    this->setCellsUsed(CCArray::create());        if (dataSource->numberOfCellsInTableView(this) > 0)    {        this->scrollViewDidScroll(this);    }    this->updateContentSize();}void GTableView::updateCellAtIndex(int idx){    if (idx == LONG_MAX || idx > dataSource->numberOfCellsInTableView(this)-1)    {        //CCLOG(@"%s: %s: invalid index", __FILE__, __FUNCTION__);        return;    }        GTableViewCell   *cell;        cell = this->cellWithIndex(idx);    if (cell)    {        this->moveCellOutOfSight(cell);    }    cell = dataSource->table_cellAtIndex(this, idx);    this->addCellIfNecessary(cell);    this->setIndex(idx, cell);    this->getCellsUsed()->addObject(cell);}void GTableView::insertCellAtIndex(int idx){    if (idx == LONG_MAX || idx > dataSource->numberOfCellsInTableView(this)-1)    {        //CCLOG(@"%s: %s: invalid index", __FILE__, __FUNCTION__);        return;    }        GTableViewCell   *cell;    CCArray *movingCells;    int        newIdx;        CCObject *cellTemp;    CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() >= idx) movingCells->addObject(cell);    }        //Pushing existing cells down.    CCARRAY_FOREACH(movingCells, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        newIdx = cell->getIdx() + 1;        this->setIndex(newIdx,cell);    }        //insert a new cell    cell = dataSource->table_cellAtIndex(this, idx);    this->addCellIfNecessary(cell);    this->setIndex(idx, cell);    cellsUsed->addObject(cell);        this->updateContentSize();}void GTableView::removeCellAtIndex(int idx){    if (idx == LONG_MAX || idx > dataSource->numberOfCellsInTableView(this)-1)    {        //CCLOG(@"%s: %s: invalid index", __FILE__, __FUNCTION__);        return;    }        CCArray *movingCells;        GTableViewCell   *cell;    int        newIdx;        cell = this->cellWithIndex(idx);    if (!cell) {        return;    }    //remove first    this->moveCellOutOfSight(cell);        //pulling cells up    CCObject *cellTemp;    CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() > idx) movingCells->addObject(cell);    }        //Pushing existing cells down.    CCARRAY_FOREACH(movingCells, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        newIdx = cell->getIdx() - 1;        this->setIndex(newIdx,cell);    }}GTableViewCell* GTableView::dequeueCell(){    GTableViewCell *cell;        this->evictCell();    if (cellsFreed->count() == 0)    {        cell = NULL;    }    else    {        cell = (GTableViewCell*) cellsFreed->objectAtIndex(0);        cell->retain();        cellsFreed->removeObjectAtIndex(0);    }    if (cell != NULL) cell->autorelease();    return cell;}void GTableView::addCellIfNecessary(GTableViewCell *cell){    if (cell->getMnode()->getParent() != this->getContainer())	{        //CCAssert(!cell.node.parent, @"GTableView: addCellIfNecessary: cell from another table view is returned from data source");        this->getContainer()->addChild(cell->getMnode());    }}void GTableView::updateContentSize(){    CCSize     size, cellSize;    int cellCount;        cellSize = dataSource->cellSizeForTable(this);    cellCount = dataSource->numberOfCellsInTableView(this);        switch (this->getDirection())    {        case GScrollViewDirectionHorizontal:            size = CCSizeMake(cellCount * cellSize.width, this->getViewSize().height);            if (size.width < this->getViewSize().width) {                size.width = this->getViewSize().width;            }            break;        default:            size = CCSizeMake(this->getViewSize().width, cellCount * cellSize.height);            if (size.height < this->getViewSize().height) {                size.height = this->getViewSize().height;            }            break;    }    this->GScrollView::setContentSize(size);}CCPoint GTableView::offsetFromIndex(int index){    CCPoint offset;    CCSize  cellSize;        //CCAssert(index != NSNotFound, @"GTableView: offsetFromIndex: invalid index");        cellSize = this->getDataSource()->cellSizeForTable(this);    switch (this->getDirection())    {        case GScrollViewDirectionHorizontal:            offset = ccp(cellSize.width * index, 0.0f);            break;        default:            offset = ccp(0.0f, cellSize.height * index);            break;    }        return offset;}int GTableView::indexFromOffset(CCPoint offset){    int  index;    CCSize     cellSize;        cellSize = this->getDataSource()->cellSizeForTable(this);        switch (this->getDirection())    {        case GScrollViewDirectionHorizontal:            index = offset.x/cellSize.width;            break;        default:            index = offset.y/cellSize.height;            break;    }        index = MAX(0, index);    index = MIN((dataSource->numberOfCellsInTableView(this))-1, index);    return index;}int GTableView::indexFromOffsetForCall(CCPoint offset){    int  index;    CCSize     cellSize;        cellSize = this->getDataSource()->cellSizeForTable(this);        switch (this->getDirection())    {        case GScrollViewDirectionHorizontal:            index = offset.x/cellSize.width;            break;        default:            index = offset.y/cellSize.height;            break;    }    if (index < 0 || index > (dataSource->numberOfCellsInTableView(this))-1) return -1;    return index;}GTableViewCell* GTableView::cellWithIndex(int cellIndex){    CCObject *cellTemp;    CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() == cellIndex) return cell;    }        return NULL;}void GTableView::moveCellOutOfSight(GTableViewCell *cell){    cellsFreed->addObject(cell);    cellsUsed->removeObject(cell);    this->getContainer()->removeChild(cell->getMnode(), true);    cell->setIdx(LONG_MAX);    cell->setMnode(NULL);}                 void GTableView::evictCell(){    if (cellsFreed->count() > 0)    {        return;    }    int        startIdx, endIdx;    CCSize            cellSize;    CCPoint           offset;        offset   = this->getContentOffset();    offset   = ccp(-offset.x, -offset.y);    cellSize = this->getDataSource()->cellSizeForTable(this);    startIdx = this->indexFromOffset(offset);        switch (this->getDirection())    {        case GScrollViewDirectionHorizontal:            offset.x += this->getViewSize().width;            offset.y =  this->getViewSize().height;            break;        default:            offset.x =  this->getViewSize().width;            offset.y += this->getViewSize().height;            break;    }    endIdx = this->indexFromOffset(offset);        CCObject *cellTemp;    CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() < startIdx) this->moveCellOutOfSight(cell);    }            CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() < startIdx) this->moveCellOutOfSight(cell);    }}void GTableView::setIndex(int index, GTableViewCell *cell){    CCPoint    offset;    CCSize     cellSize;    CCNode     *item;	    //CCAssert(cell != nil, @"GTableView: setIndex:forCell: cell is nil!");        offset   = this->offsetFromIndex(index);    cellSize = this->getDataSource()->cellSizeForTable(this);        if (!CCSize::CCSizeEqualToSize(cell->getMnode()->getContentSize(), cellSize))    {        //CCLOG(@"%s: %s: inconsistent cell size", __FILE__, __FUNCTION__);    }        item = cell->getMnode();    item->setAnchorPoint(ccp(0.0f, 0.0f));    item->setPosition(offset);    cell->setIdx(index);}void GTableView::scrollViewDidScroll(GScrollView *view){    int        startIdx, endIdx;    CCSize            cellSize;    CCPoint           offset;        offset   = this->getContentOffset();    offset   = ccp(-offset.x, -offset.y);    cellSize = this->getDataSource()->cellSizeForTable(this);    startIdx = this->indexFromOffset(offset);        switch (this->getDirection())    {        case GScrollViewDirectionHorizontal:            offset.x += this->getViewSize().width;            offset.y =  this->getViewSize().height;            break;        default:            offset.x =  this->getViewSize().width;            offset.y += this->getViewSize().height;            break;    }    endIdx = this->indexFromOffset(offset);        CCObject *cellTemp;    CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() < startIdx) this->moveCellOutOfSight(cell);    }        CCARRAY_FOREACH(cellsUsed, cellTemp)    {        GTableViewCell *cell = (GTableViewCell*) cellTemp;        if (cell->getIdx() < startIdx) this->moveCellOutOfSight(cell);    }        for (int i=startIdx; i <= endIdx; i++) {        if (this->cellWithIndex(i)) {            continue;        }        this->updateCellAtIndex(i);    }    //CCLOG(@"%s: %s: cells in use: %i", __FILE__, __FUNCTION__, [cellsUsed count]);    //CCLOG(@"%s: %s: cells in free list: %i", __FILE__, __FUNCTION__, [cellsFreed count]);}void GTableView::ccTouchesEnded(CCSet *touches, CCEvent *event){    if (!this->isVisible())    {        return;    }    if (touches->count() == 1 && !this->getTouchMoved() && !CCPoint::CCPointEqualToPoint(ccp(-1.0f, -1.0f), this->getTouchPoint()) && this->getIsEnabled())    {        CCPoint           localPoint;        int        index;        GTableViewCell   *cell;                localPoint = this->getContentOffset();        localPoint = ccpAdd(ccp(-localPoint.x, -localPoint.y), this->getTouchPoint());        index      = this->indexFromOffsetForCall(localPoint);        if (index == -1)        {            this->GScrollView::ccTouchesEnded(touches, event);            return;        }        cell       = this->cellWithIndex(index);                //CCAssert(cell, @"GTableView: no cell exists with that index");                localPoint = this->convertToWorldSpace(this->getTouchPoint());        localPoint = cell->getMnode()->convertToNodeSpace(localPoint);                tDelegate->table_cellTouched(this, cell, localPoint);    }    this->GScrollView::ccTouchesEnded(touches, event);}