////  GMultiTableView.m//  GTable////  Created by Sangwoo Im on 6/3/10.//  Copyright 2010 Sangwoo Im. All rights reserved.//#include "GMultiTableView.h"#include "GTableViewCell.h"G_SYNTHESIZE_IMPLEMENT_GET(int, colCount, ColCount, GMultiTableView);GMultiTableView* GMultiTableView::multiTableView(GTableViewDataSource *dataSource, CCSize size){    GMultiTableView *table;    table = new GMultiTableView();    table->initWithViewSize(size);    table->setDataSource(dataSource);    table->updateContentSize();    table->autorelease();    return table;}bool GMultiTableView::initWithViewSize(CCSize size){    this->GTableView::initWithViewSize(size);    this->setColCount(1);    return true;}void GMultiTableView::setColCount(int cols){    colCount = cols;    if (this->getDirection() == GScrollViewDirectionBoth)    {        this->updateContentSize();    }    else	{        //CCLog(@"%s: %s: You cannot set this value. The value will ignored and overwritten.", FILE, FUNCTION);    }}int GMultiTableView::indexFromOffset(CCPoint offset){    int  index;    CCSize     cellSize;    int col, row;    CCFloat    spaceWidth;        cellSize = this->getDataSource()->cellSizeForTable(this);        switch (this->getDirection()) {        case GScrollViewDirectionBoth:            spaceWidth = this->getContentSize().width / colCount;            col        = (offset.x - (spaceWidth - cellSize.width)*0.5)/spaceWidth;            row        = offset.y / cellSize.height;            break;        case GScrollViewDirectionHorizontal:            colCount   = this->getViewSize().height / cellSize.height;            spaceWidth = this->getViewSize().height / colCount;            col        = (offset.y - (spaceWidth - cellSize.height)*0.5)/spaceWidth;            row        = offset.x / cellSize.width;            break;        default:            colCount   = this->getViewSize().width / cellSize.width;            spaceWidth = this->getViewSize().width / colCount;            col        = (offset.x - (spaceWidth - cellSize.width)*0.5)/spaceWidth;            row        = offset.y / cellSize.height;            break;    }    index = col + row * colCount;    index = MAX(0, index);    index = MIN(this->getDataSource()->numberOfCellsInTableView(this)-1, index);    return index;}int GMultiTableView::indexFromOffsetForCall(CCPoint offset){    int  index;    CCSize     cellSize;    int col, row;    CCFloat    spaceWidth;        cellSize = this->getDataSource()->cellSizeForTable(this);        switch (this->getDirection()) {        case GScrollViewDirectionBoth:            spaceWidth = this->getContentSize().width / colCount;            col        = (offset.x - (spaceWidth - cellSize.width)*0.5)/spaceWidth;            row        = offset.y / cellSize.height;            break;        case GScrollViewDirectionHorizontal:            colCount   = this->getViewSize().height / cellSize.height;            spaceWidth = this->getViewSize().height / colCount;            col        = (offset.y - (spaceWidth - cellSize.height)*0.5)/spaceWidth;            row        = offset.x / cellSize.width;            break;        default:            colCount   = this->getViewSize().width / cellSize.width;            spaceWidth = this->getViewSize().width / colCount;            col        = (offset.x - (spaceWidth - cellSize.width)*0.5)/spaceWidth;            row        = offset.y / cellSize.height;            break;    }    index = col + row * colCount;    if (index < 0 || index > (this->getDataSource()->numberOfCellsInTableView(this)-1)) return -1;    return index;}CCPoint GMultiTableView::offsetFromIndex(int index){    CCPoint    offset;    CCSize     cellSize;    CCFloat    spaceWidth;    int col, row;        //CCAssert(index != NSNotFound, @"CCTableView: offsetFromIndex: invalid index");        cellSize = this->getDataSource()->cellSizeForTable(this);    switch (this->getDirection()) {        case GScrollViewDirectionBoth:            row        = index / colCount;            col        = index % colCount;            spaceWidth = this->getContentSize().width / colCount;            offset     = ccp(col * spaceWidth + (spaceWidth - cellSize.width) * 0.5,                             row * cellSize.height);            break;        case GScrollViewDirectionHorizontal:            colCount   = this->getViewSize().height / cellSize.height;            row        = index / colCount;            col        = index % colCount;            spaceWidth = this->getViewSize().height / colCount;            offset     = ccp(row * cellSize.height,                             col * spaceWidth + (spaceWidth - cellSize.width) * 0.5);            break;        default:            colCount   = this->getViewSize().width / cellSize.width;            row        = index / colCount;            col        = index % colCount;            spaceWidth = this->getViewSize().width / colCount;            offset     = ccp(col * spaceWidth + (spaceWidth - cellSize.width) * 0.5,                             row * cellSize.height);            break;    }        return offset;}void GMultiTableView::updateContentSize(){    CCSize     size, cellSize;    int cellCount, rows;        cellSize  = this->getDataSource()->cellSizeForTable(this);    cellCount = this->getDataSource()->numberOfCellsInTableView(this);    switch (this->getDirection()) {        case GScrollViewDirectionBoth:            rows     = ceilf(cellCount/((CCFloat)colCount));            size     = CCSizeMake(cellSize.width * colCount, rows * cellSize.height);            break;        case GScrollViewDirectionHorizontal:            colCount = this->getViewSize().height / cellSize.height;            rows     = ceilf(cellCount/((CCFloat)colCount));            size     = CCSizeMake(rows * cellSize.width, colCount * cellSize.height);            break;        default:            colCount = this->getViewSize().width / cellSize.width;            rows     = ceilf(cellCount/((CCFloat)colCount));            size     = CCSizeMake(cellSize.width * colCount, rows * cellSize.height);            break;    }    this->setContentSize(size);}